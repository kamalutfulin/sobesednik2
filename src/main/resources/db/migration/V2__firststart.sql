INSERT INTO questions (question, answer) VALUES
--
--
--                                                 Java Core


('Что такое класс Object? Какие в нем есть методы?', '<b>Object</b> - это базовый класс для всех остальных объектов в Java. Любой класс наследуется от Object и, соответственно, наследуют его методы:<br>
• <b>clone()</b> - создает новый объект, не отличающийся от клонируемого.<br>
• <b>equals</b> - определяет, равен ли один объект другому.<br>
• <b>finalize()</b> - вызывается перед удалением неиспользуемого объекта.<br>
• <b>getClass()</b> - получает класс объекта во время выполнения.<br>
• <b>hashCode()</b> - возвращает хэш-код, связанный с вызывающим объектом.<br>
• <b>notify()</b> - возобновляет исполнение потока, ожидающего вызывающего объекта.<br>
• <b>notifyAll()</b> - возобновляет исполнение всех потоков, ожидающих вызывающего объекта.<br>
• <b>toString()</b> - возвращает символьную строку, описывающую объект.<br>
• <b>wait()</b> - ожидает другого потока исполнения.'),

('ООП Инкапсуляция,Наследование,Полиморфизм,Абстракция', '• <b>Инкапсуляция</b> - сокрытие реализации и предоставление пользователю управления<br>
• <b>Наследование</b> - создание новой сущности на базе уже существующей<br>
• <b>Полиморфизм</b> – это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта<br>
• <b>Абстракция</b> – это выделение важных характеристик объекта и исключение незначимые'),

('Чем различаются JRE, JVM и JDK?', '• <b>JVM, Java Virtual Machine</b> - Виртуальная машина Java<br>
• <b>JRE, Java Runtime Environment</b> - минимально-необходимая реализация виртуальной машины для исполнения Java-приложений. Состоит из JVM и стандартного набора библиотек классов Java<br>
• <b>JDK, Java Development Kit</b> - JRE и набор инструментов разработчика приложений на языке Java, включающий в себя компилятор Java, стандартные библиотеки классов Java, примеры, документацию, различные утилиты'),


('Какие существуют модификаторы доступа?', '• <b>private</b> - только внутри класса<br>
• <b>default</b> - видимость класса/членов класса только внутри пакета<br>
• <b>protected</b> - внутри пакета и в наследниках<br>
• <b>public</b> - класс/члены класса доступны всем'),

('Чем отличаются final, finally и finalize()?', 'Модификатор <b>final</b>:<br>
-Класс не может иметь наследников;<br>
-Метод не может быть переопределен в классах наследниках;<br>
-Поле не может изменить свое значение после инициализации;<br>
-Локальные переменные не могут быть изменены после присвоения им значения;<br>
-Параметры методов не могут изменять своё значение внутри метода.<br><br>
Оператор <b>finally</b> гарантирует, что определенный в нём участок кода будет выполнен независимо от того, какие исключения были возбуждены и перехвачены в блоке try-catch.<br><br>
Метод <b>finalize()</b> вызывается перед тем как сборщик мусора будет проводить удаление объекта.'),

('О чем говорит ключевое слово final', 'Модификатор final может применяться к переменным, параметрам методов, полям и методам класса или самим классам.<br>
    • Класс не может иметь наследников;<br>
    • Метод не может быть переопределен в классах наследниках;<br>
    • Поле не может изменить свое значение после инициализации;<br>
    • Параметры методов не могут изменять своё значение внутри метода;<br>
    • Локальные переменные не могут быть изменены после присвоения им значения<br>'),


('Какая основная разница между String, StringBuffer, StringBuilder?', '• Класс <b>String</b> является неизменяемым (immutable) - модифицировать объект такого класса нельзя, можно лишь заменить его созданием нового экземпляра.<br>
• Класс <b>StringBuffer</b> изменяемый - использовать StringBuffer следует тогда, когда необходимо часто модифицировать содержимое.<br>
• Класс <b>StringBuilder</b> был добавлен в Java 5 и он во всем идентичен классу StringBuffer за исключением того, что он не синхронизирован и поэтому его методы выполняются значительно быстрей.'),

('Optional - что это?', '<b>Optional</b> — это контейнер для объекта, который может содержать или не содержать значение null. Такая обёртка является удобным средством предотвращения NullPointerException'),


--                                                 Exception


('Какие виды исключений в Java вы знаете, чем они отличаются?Что такое checked и unchecked exception?', 'В Java все исключения делятся на два типа:<br>
• <b>checked</b> (контролируемые/проверяемые исключения) должны обрабатываться блоком catch или описываться в сигнатуре метода (например, throws IOException). Наличие такого обработчика/модификатора сигнатуры проверяются на этапе компиляции;<br>
• <b>unchecked</b> (неконтролируемые/непроверяемые исключения), к которым относятся ошибки Error (например, OutOfMemoryError), обрабатывать которые не рекомендуется и исключения времени выполнения, представленные классом RuntimeException и его наследниками (например, NullPointerException), которые могут не обрабатываться блоком catch и не быть описанными в сигнатуре метода.'),

('Ключевые слова try/catch/finally/throw/trows', '• <b>try</b> — данное ключевое слово используется для отметки начала блока кода, который потенциально может привести к ошибке.<br>
• <b>catch</b> — ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений.<br>
• <b>finally</b> — ключевое слово для отметки начала блока кода, которой является дополнительным. Этот блок помещается после последнего блока ‘catch’. Управление обычно передаётся в блок ‘finally’ в любом случае.<br>
• <b>throw</b> — служит для генерации исключений.<br>
• <b>throws</b> — ключевое слово, которое прописывается в сигнатуре метода, и обозначающее что метод потенциально может выбросить исключение с указанным типом.'),

('Конструкция try-with-resources', 'Данная конструкция, позволяет использовать блок try-catch не заботясь о закрытии ресурсова. Ресурсы объявляются в скобках сразу после try, а компилятор уже сам неявно создаёт секцию finally, в которой и происходит освобождение занятых в блоке ресурсов. <br>
Под ресурсами подразумеваются сущности, реализующие интерфейс java.lang.Autocloseable.'),


--                                                 Stream API


('Stream API - что это?', '<b>Stream API</b> - Инструмент для работы с коллекциями в функциональный стиль<br>
Предлагает два вида методов:
1. <b>Конвейерные</b> — возвращают другой stream (может быть сколько угодно)
2. <b>Терминальные</b> — возвращают другой объект, такой как коллекция, примитивы, объекты( ставится в конце и в единственном экземпляре) <br><br>
Конвейерные — filter,skip,distinct,limit<br>
Терминальные — collect,min,max'),


--                                                 Многопоточность


('Состояния потоков', 'Поток может находиться в одном из следующих состояний:<br>
• <b>New</b> - объект класса Thread создан, но еще не запущен. Он еще не является потоком выполнения и естественно не выполняется.<br>
• <b>Runnable</b> - поток готов к выполнению, но планировщик еще не выбрал его.<br>
• <b>Running</b> – поток выполняется.<br>
• <b>Waiting/blocked/sleeping</b> - поток блокирован или поток ждет окончания работы другого потока.'),

('Методы sleep,yield,join,start,run', 'Поток может находиться в одном из следующих состояний:<br>
• <b>Sleep</b> - приостанавливает выполнение потока на заданное время.<br>
• <b>isAlive()</b> - определить, выполняется ли поток.<br>
• <b>setPriority()</b> - установить приоритет<br>
• <b>yield()</b> возвращает выполняющийся поток в состоянии runnable, для того чтобы уступить место другому потоку.<br>
• <b>join</b> – Этот метод приостановит выполнение текущего потока до тех пор, пока другой поток не закончит свое выполнение.<br>
• <b>start</b> - запускает поток<br>
• <b>run</b> - будет выполнен в потоке. В этом методе программист пишет то, что должно быть выполнено.<br>'),

('Что такое «монитор» в Java?', '<b>Монитор, мьютекс (mutex)</b> – это средство обеспечения контроля за доступом к ресурсу. У монитора может быть максимум один владелец. <br>
Следовательно, если кто-то использует ресурс и захватил монитор для обеспечения единоличного доступа, то другой, желающий использовать тот же ресурс, должен подождать освобождения монитора, захватить его и только потом начать использовать ресурс.'),


--                                                 Spring


('Какие вы знаете различные scope у Spring Bean?', '• <b>singleton</b> — может быть создан только один экземпляр бина. Этот тип используется спрингом по умолчанию, если не указано другое.<br>
• <b>prototype</b> — создается новый экземпляр при каждом запросе<br>
• <b>request</b> —  аналогичен prototype, но название служит пояснением к использованию бина в веб приложении. Создается новый экземпляр при каждом HTTP request<br>
• <b>session</b> — новый бин создается в контейнере при каждой новой HTTP сессии<br>
• <b>global-session</b>: используется для создания глобальных бинов на уровне сессии для Portlet  приложений<br>'),

('Что такое Spring Boot?', '<b>Spring Boot</b> – это фреймворк, используемый для создания микросервисов. Это проект, построенный на основе Spring, чтобы упростить задачу развертывания приложений Java.<br>
Его двумя основными компонентами являются Spring Framework и встроенные HTTP-серверы. '),

('Каковы этапы жизненного цикла компонента?', 'Жизненный цикл компонента состоит из семи этапов:<br>
1.Создать экземпляр: Компонент создается контейнером Spring с использованием определения компонента, найденного в файле конфигурации XML.<br>
2.Заполнение свойств: Spring заполняет все определенные свойства из XML-файла с помощью внедрения зависимостей.<br>
3.Установить имя компонента: Spring передает идентификатор компонента методу setBeanName (), если компонент использует интерфейс BeanNameAware.<br>
4.Установить baen factory: Spring передает beanfactory методу setBeanFactory (), если компонент настроен на использование интерфейса BeanFactoryAware.<br>
5.Предварительная инициализация: Spring вызывает любые BeanPostProcessors, связанные с компонентом, с помощью метода postProcessorBeforeInitialization ().<br>
6.Инициализация: Затем инициализируется компонент. Выполняется любой специальный процесс инициализации, указанный в методе инициализации.<br>
7.Постинициализация: Вызываются все определенные методы postProcessAfterInitialization (). Теперь bean завершен. Компоненты, реализующие DisposableBean, будут удалены с помощью функции destroy() после завершения их работы.<br>'),


--                                                 DB


('В чем отличие между кластерными и некластерными индексами?', '• <b>Некластерные индексы</b> - данные физически расположены в произвольном порядке, но логически упорядочены согласно индексу. Такой тип индексов подходит для часто изменяемого набора данных.<br>
При <b>кластерном</b> индексировании данные физически упорядочены, что серьезно повышает скорость выборок данных (но только в случае последовательного доступа к данным). Для одного набора данных может быть создан только один кластерный индекс.'),

('Транзакция и ACID', '<b>Транзакция</b> - это единая логическая операция, которая может состоять из одного или нескольких шагов.<br>
• <b>Атомарность</b> - выражается в том, что транзакция должна быть выполнена в целом или не выполнена вовсе.<br>
• <b>Согласованность</b> - гарантирует, что по мере выполнения транзакций, данные переходят из одного согласованного состояния в другое, то есть транзакция не может разрушить взаимной согласованности данных.<br>
• <b>Изолированность</b> - Во время выполнения транзакции другие транзакции не должны оказывать влияние на её результат.<br>
• <b>Долговечность</b> - Eсли транзакция завершена успешно, то те изменения в данных, которые были ею произведены, не могут быть потеряны ни при каких обстоятельствах'),

('Проблемы и Уровни изоляции', '• <b>Потерянное обновление</b> - Ситуация, когда при одновременном изменении одного блока данных разными транзакциями одно из изменений теряется.<br>
• <b>Грязное» чтение</b> - Чтение данных, добавленных или изменённых транзакцией, которая впоследствии не подтвердится (откатится).<br>
• <b>Неповторяющееся чтение</b> - Ситуация, когда при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными.<br>
• <b>Фантомное чтение</b> - Ситуация, когда при повторном чтении в рамках одной транзакции одна и та же выборка дает разные множества строк.<br><br>
• <b>READ UNCOMMITTED</b> - Ситуация, когда при повторном чтении в рамках одной транзакции одна и та же выборка дает разные множества строк.<br>
• <b>READ COMMITTED</b> - Ситуация, когда при повторном чтении в рамках одной транзакции одна и та же выборка дает разные множества строк.<br>
• <b>REPEATABLE READ</b> - Ситуация, когда при повторном чтении в рамках одной транзакции одна и та же выборка дает разные множества строк.<br>
• <b>SERIALIZABLE</b> - Ситуация, когда при повторном чтении в рамках одной транзакции одна и та же выборка дает разные множества строк.<br>'),

--                                                  Hibernate


('Назовите некоторые важные аннотации, используемые для отображения в Hibernate', 'Hibernate поддерживает как аннотации из JPA, так и свои собственные, которые находятся в пакете org.hibernate.annotations. Наиболее важные аннотации JPA и Hibernate:<br>
• <b>@Entity</b>: используется для указания класса как entity bean.<br>
• <b>@Table</b>: используется для определения имени таблицы из БД, которая будет отображаться на entity bean.<br>
• <b>@Access</b>: определяет тип доступа, поле или свойство. Поле — является значением по умолчанию и если нужно, чтобы hibernate использовал методы getter/setter, то их необходимо задать для нужного свойства.<br>
• <b>@Id</b>: определяет primary key в entity bean.<br>
• <b>@EmbeddedId</b>: используется для определения составного ключа в бине.<br>
• <b>@Column</b>: определяет имя колонки из таблицы в базе данных.<br>
• <b>@GeneratedValue</b>: задает стратегию создания основных ключей. Используется в сочетании с javax.persistence.GenerationType enum.<br>
• <b>@OneToOne</b>: задает связь один-к-одному между двумя сущностными бинами. Соответственно есть другие аннотации OneToMany, ManyToOne и ManyToMany.<br>
• <b>@Cascade</b>: определяет каскадную связь между двумя entity бинами. Используется в связке с org.hibernate.annotations.CascadeType.<br>
• <b>@PrimaryKeyJoinColumn</b>: определяет внешний ключ для свойства. Используется вместе с org.hibernate.annotations.GenericGenerator и org.hibernate.annotations.Parameter.'),

('Какие существуют различные состояния у entity bean?', '<b>Transient</b>: состояние, при котором объект не  связан с какой-либо сессией и не является персистентностью.<br>Этот объект находится во временном состоянии. Объект в этом состоянии может стать персистентным при вызове метода save(), persist() или saveOrUpdate(). Объект персистентности может перейти в transient состоянии после вызова метода delete().<br>
<b>Persistent</b>: когда объект связан с уникальной сессией он находится в состоянии persistent (персистентности). Любой экземпляр, возвращаемый методами get() или load() находится в состоянии persistent.<br>
<b>Detached</b>: если объект был персистентным, но сейчас не связан с какой-либо сессией, то он находится в отвязанном (detached) состоянии. Такой объект можно сделать персистентным используя методы update(), saveOrUpdate(), lock() или replicate(). Состояния transient или detached так же могут перейти в состояние persistent как новый объект персистентности после вызова метода merge().
'),

('Чем отличается Lazy от Eager в Hibernate?', '<b>Eager Loading</b> — стратегия загрузки, при которой подгрузка связанных сущностей происходит сразу. Для применения необходимо в аннотацию отношения (@OneToOne, @ManyToOne, @OneToMany, @ManyToMany) передать fetch = FetchType.EAGER. Используется по умолчанию для отношений @OneToOne и @ManyToOne.<br>
<b>Lazy Loading</b> — стратегия загрузки, при которой подгрузка связанных сущностей откладывается как можно дольше. Чтобы задать такое поведение, нужно в аннотацию отношения (@OneToOne, @ManyToOne, @OneToMany, @ManyToMany) передать fetch = FetchType.LAZY. Используется по умолчанию для отношений @OneToMany, @ManyToMany. До момента загрузки используется proxy-объект, вместо реального. Если обратиться к такому LAZY-полю после закрытия сессии Hibernate, то получим LazyInitializationException.'),


--                                                 SOLID


('SOLID', 'Принципы SOLID способствует созданию такой системы, которую будет легко поддерживать и расширять в течение долгого времени<br> • <b>Принцип единственной ответственности</b> - Каждый модуль должен отвечать только за одну заинтересованную группу.<br>
• <b>Принцип открытости/закрытости</b> - Программа должны быть открыты для расширения и закрыты для изменения.<br>
• <b>Принцип подстановки Барбары Лисков</b> — Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.<br>
• <b>Принцип разделения интерфейсов</b> — Разделение интерфейса облегчает использование и тестирование модулей. Много интерфейсов лучше чем один с большим кол-вом методов<br>
• <b>Принцип инверсии зависимости</b> - Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.<br>
Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.<br>
Модули, работающие с BD, интерфейсом пользователя, низкого уровня. А модули, реализующие бизнес-логику — высокого уровня.
' ),


--                                                 СТРУКТУРЫ ДАННЫХ/АЛГОРИТМЫ


('Перечислите структуры данных', '<b>Массивы</b><br>
• <b>Связанные списки</b><br>
• <b>Стеки</b><br>
• <b>Очереди</b><br>
• <b>Деревья</b><br>
• <b>Хэш таблицы</b>' ),


--                                                 REST


('REST', '<b>REST</b> - архитектурный стиль взаимодействия компонентов распределённого приложения в сети.<br> <b>Требования к Rest приложению:</b><br>
• <b>Модель клиент-сервер</b> - Система должна быть разделена на клиентов и на серверов.<br>
• <b>Отсутствие состояния</b> — Сервер не должен хранить какой-либо информации о клиентах. В запросе должна храниться вся необходимая информация для обработки запроса и если необходимо, идентификации клиента.<br>
• <b>Кэширование</b> — Каждый ответ должен быть отмечен является ли он кэшируемым или нет<br>
• <b>Единообразие интерфейса</b> - Универсальный интерфейс между компонентами системы.<br>
• <b>Слои</b> - В REST допускается разделить систему на иерархию слоев но с условием, что каждый компонент может видеть компоненты только непосредственно следующего слоя.<br>
• <b>Код по требованию</b> - В REST позволяется загрузка и выполнение кода или программы на стороне клиента.<br>' ),


--                                                 SOAP


('SOAP', '<b>SOAP</b> - это формат обмена данными. С SOAP это всегда SOAP-XML, который представляет собой XML, включающий:<br>
• <b>Envelope</b> (конверт) – корневой элемент, который определяет сообщение и пространство имен, использованное в документе,<br>
• <b>Header</b> (заголовок) – содержит атрибуты сообщения, например: информация о безопасности или о сетевой маршрутизации,<br>
• <b>Body</b> (тело) – содержит сообщение, которым обмениваются приложения,<br>
• <b>Fault</b> – необязательный элемент, который предоставляет информацию об ошибках, которые произошли при обработке сообщений. И запрос, и ответ должны соответствовать структуре SOAP.' ),



('mock и spy отличия?', 'пустышка (dummy) - объект, который обычно передается в тестируемый класс в качестве параметра, но не имеет поведения: с ним ничего не происходит и никакие его методы не вызываются.
Примером dummy-объектов являются new object(), null, «Ignored String» и т.д.
фальшивка (fake object) применяется в основном для ускорения запуска ресурсоёмких тестов и является заменой тяжеловесного внешнего зависимого объекта его легковесной реализацией.
Основные примеры — эмулятор базы данных (fake database) или фальшивый web-сервис.
заглушка (test stub) используется для получения данных из внешней зависимости, подменяя её. При этом заглушка игнорирует все данные, поступающие из тестируемого объекта, возвращая заранее определённый результат.
Тестируемый объект использует чтение из конфигурационного файла? Тогда передаем ему заглушку ConfigFileStub возвращающую тестовые строки конфигурации без обращения к файловой системе.
шпион (test spy) - разновидность заглушки, которая умеет протоколировать сделанные к ней обращения из тестируемой системы, чтобы проверить их правильность в конце теста. При этом фиксируется количество, состав и содержание параметров вызовов.');